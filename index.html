<!doctype html>

<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Neon Runner — Deluxe (Cosmic)</title>
  <link rel="icon" href="data:,">
  <style>
    :root{
      --bg1:#02020a; --bg2:#071228; --accent:#49f0ff; --accent2:#ff5df0; --accent3:#70ff61;
      --panel: rgba(255,255,255,0.03); --panelBorder: rgba(255,255,255,0.08);
    }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;font-family:Inter,ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;color:#eafcff;background:radial-gradient(1200px 800px at 60% 25%,var(--bg2),var(--bg1));-webkit-font-smoothing:antialiased}
    .app{position:relative;height:100vh;overflow:hidden}
    canvas{display:block;width:100vw;height:100vh}

    /* UI */
    .menu{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);width:min(880px,94vw);background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(255,255,255,0.01));border:1px solid var(--panelBorder);border-radius:16px;padding:28px;backdrop-filter:blur(8px);box-shadow:0 12px 46px rgba(0,0,0,0.65);text-align:center;z-index:120}
    .menu h1{margin:0;color:var(--accent);font-size:40px;text-shadow:0 10px 36px rgba(73,240,255,0.14)}
    .subtitle{color:rgba(255,255,255,0.88);margin-top:8px}
    .card{margin:18px auto;background:var(--panel);border-radius:12px;padding:16px;border:1px solid var(--panelBorder);text-align:left}
    .menu-actions{display:flex;gap:12px;justify-content:center;margin-top:12px}

    button{font-weight:800;border-radius:12px;padding:12px 18px;border:none;cursor:pointer}
    .primary{background:linear-gradient(180deg,var(--accent),#28d8e6);color:#021013;box-shadow:0 10px 28px rgba(73,240,255,0.18)}
    .secondary{background:transparent;color:#fff;border:2px solid rgba(73,240,255,0.12)}

    /* HUD */
    .hud{position:fixed;left:50%;top:12px;transform:translateX(-50%);background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(255,255,255,0.01));border:1px solid var(--panelBorder);padding:10px 14px;border-radius:12px;backdrop-filter:blur(6px);display:flex;gap:12px;align-items:center;z-index:110}
    .stat{font-weight:700;color:rgba(255,255,255,0.95)}
    .pulse{animation:pulse 420ms ease-out}
    @keyframes pulse{0%{transform:scale(1)}50%{transform:scale(1.08)}100%{transform:scale(1)}}

    /* controls */
    .controls{position:fixed;left:90%;bottom:12px;transform:translateX(-50%);display:flex;gap:10px;background:var(--panel);border:1px solid var(--panelBorder);padding:10px;border-radius:12px;z-index:100}
    .touch-controls{position:fixed;left:50%;bottom:12px;transform:translateX(-50%);display:none;gap:50px;z-index:130}
    .touch-btn{width:72px;height:72px;border-radius:12px;border:2px solid rgba(73,240,255,0.12);background:linear-gradient(180deg,rgba(73,240,255,0.04),rgba(255, 255, 255, 0.35));font-size:18px}
    @media(max-width:760px){.controls{display:none}.touch-controls{display:flex}}

    /* overlays */
    .overlay{position:fixed;inset:0;background:rgba(0,0,0,0.6);display:flex;align-items:center;justify-content:center;z-index:140}
    .overlay-content{background:var(--panel);border-radius:14px;padding:28px 32px;border:1px solid var(--panelBorder);backdrop-filter:blur(8px);text-align:center;min-width:280px}

    /* scoreboard */
    #scoreList{list-style:none;padding:0;margin:8px 0 18px;max-height:290px;overflow:auto}
    #scoreList li{padding:8px;border-bottom:1px dashed rgba(255,255,255,0.03)}

    /* toast */
    .toast{position:fixed;right:18px;top:18px;background:var(--panel);border:1px solid var(--panelBorder);padding:8px 12px;border-radius:8px;z-index:160}

    .muted{color:rgba(255,255,255,0.7);font-size:13px}
  </style>
</head>
<body>
  <div class="app">
    <canvas id="game"></canvas>

    <div id="menu" class="menu">
      <h1>Neon Runner — Cosmic</h1>
      <p class="subtitle">Cosmic neon, comet dash, endless procedural stages.</p>
      <div class="card">
        <h3>Tips</h3>
        <ul>
          <li><strong>Goal:</strong> reach the glowing green orb at the far right.</li>
          <li><strong>Purple tiles:</strong> teleport you — use with care.</li>
          <li><strong>Dash:</strong> hold momentum for comet trails and combos.</li>
        </ul>
      </div>
      <div class="menu-actions">
        <button id="startBtn" class="primary">Start</button>
        <button id="scoreBtn" class="secondary">High Scores</button>
        <button id="settingsBtn" class="secondary">Settings</button>
      </div>
      <p class="muted">Best viewed in modern browsers. Sound + visuals can be adjusted.</p>
    </div>

    <div id="hud" class="hud" aria-live="polite">
      <div id="lives" class="stat">Lives: 5</div>
      <div id="stage" class="stat">Stage: 1</div>
      <div id="score" class="stat">Score: 0</div>
    </div>

    <div id="controls" class="controls">
      <div class="key"><div>← / A</div><div class="muted">Move</div></div>
      <div class="key"><div>Space</div><div class="muted">Jump</div></div>
      <div class="key"><div>Shift</div><div class="muted">Dash</div></div>
    </div>

    <div id="touchControls" class="touch-controls">
      
      <button data-key="Space" class="touch-btn">⭡</button>
      <button data-key="ShiftLeft" class="touch-btn">Dash</button>
      <button data-key="ArrowLeft" class="touch-btn">◀</button>
      <button data-key="ArrowRight" class="touch-btn">▶</button>
    </div>

    <div id="toast" class="toast" style="display:none"></div>

    <div id="winScreen" class="overlay" style="display:none">
      <div class="overlay-content">
        <h1 style="color:var(--accent3)">Stage Cleared!</h1>
        <p id="stageMsg"></p>
        <div style="display:flex;gap:10px;justify-content:center">
          <button id="nextBtn" class="primary">Next</button>
          <button id="homeBtn" class="secondary">Home</button>
        </div>
      </div>
    </div>

    <div id="gameOver" class="overlay" style="display:none">
      <div class="overlay-content">
        <h1 style="color:var(--accent2)">Game Over</h1>
        <p id="finalScore"></p>
        <div style="display:flex;gap:10px;justify-content:center">
          <button id="restartBtn" class="primary">Restart</button>
          <button id="backBtn" class="secondary">Home</button>
        </div>
      </div>
    </div>

    <div id="scoreBoard" class="overlay" style="display:none">
      <div class="overlay-content">
        <h1>High Scores</h1>
        <ul id="scoreList"></ul>
        <div style="display:flex;gap:10px;justify-content:center">
          <button id="closeScore" class="primary">Back</button>
          <button id="clearScore" class="secondary">Clear</button>
        </div>
      </div>
    </div>

    <div id="settings" class="overlay" style="display:none">
      <div class="overlay-content">
        <h2>Settings</h2>
        <div style="margin:10px 0;display:flex;gap:8px;align-items:center;justify-content:center"><label>Performance:</label>
          <select id="perf" aria-label="Performance preset"><option value="balanced">Balanced</option><option value="high">High visual</option><option value="mobile">Mobile</option></select>
        </div>
        <div style="margin:10px 0;display:flex;gap:8px;align-items:center;justify-content:center"><label>SFX:</label>
          <input id="sfxToggle" type="checkbox" checked /></div>
        <div style="display:flex;gap:10px;justify-content:center;margin-top:12px">
          <button id="closeSettings" class="primary">Close</button>
        </div>
      </div>
    </div>

  </div>

  <script>
  window.addEventListener('DOMContentLoaded', () => {
    // DOM refs
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d', { alpha: false });
    const menu = document.getElementById('menu');
    const startBtn = document.getElementById('startBtn');
    const scoreBtn = document.getElementById('scoreBtn');
    const hud = document.getElementById('hud');
    const statsLives = document.getElementById('lives');
    const statsStage = document.getElementById('stage');
    const statsScore = document.getElementById('score');
    const controls = document.getElementById('controls');
    const touchControls = document.getElementById('touchControls');
    const toastEl = document.getElementById('toast');
    const winScreen = document.getElementById('winScreen');
    const stageMsg = document.getElementById('stageMsg');
    const nextBtn = document.getElementById('nextBtn');
    const homeBtn = document.getElementById('homeBtn');
    const gameOver = document.getElementById('gameOver');
    const finalScore = document.getElementById('finalScore');
    const restartBtn = document.getElementById('restartBtn');
    const backBtn = document.getElementById('backBtn');
    const scoreBoard = document.getElementById('scoreBoard');
    const scoreList = document.getElementById('scoreList');
    const closeScore = document.getElementById('closeScore');
    const clearScore = document.getElementById('clearScore');
    const settings = document.getElementById('settings');
    const settingsBtn = document.getElementById('settingsBtn');
    const closeSettings = document.getElementById('closeSettings');
    const perfSelect = document.getElementById('perf');
    const sfxToggle = document.getElementById('sfxToggle');

    // state
    let running = false, gameStarted = false, levelCleared = false;
    let stageCounter = 0, lives = 5, score = 0;
    const TILE = 32;
    const level = { width: 180, height: 24, tiles: [], spawn: {x:2*TILE,y:2*TILE}, goalBox:{x:0,y:0,w:0,h:0} };

    // performance config + accents
    const config = {
      dpr: Math.max(1, Math.min(2, window.devicePixelRatio || 1)),
      particleLimit: 350,
      starCount: 260,
      sfx: true,
      accent1: '#49f0ff',
      accent2: '#ff5df0',
      accent3: '#70ff61'
    };

    // input
    const keys = new Set();
    const keyOnce = new Set();
    window.addEventListener('keydown', e => { if(['Space','ShiftLeft','ShiftRight','ArrowLeft','ArrowRight','KeyA','KeyD'].includes(e.code)) e.preventDefault(); keys.add(e.code); keyOnce.add(e.code); });
    window.addEventListener('keyup', e => keys.delete(e.code));

    // resize
    function resize(){
      config.dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
      canvas.width = Math.floor(window.innerWidth * config.dpr);
      canvas.height = Math.floor(window.innerHeight * config.dpr);
      ctx.setTransform(config.dpr,0,0,config.dpr,0,0);
    }
    window.addEventListener('resize', resize); resize();

    // helpers
    function clamp(v,a,b){return Math.max(a,Math.min(b,v))}
    function lerp(a,b,t){return a + (b-a)*t}
    function easeOut(t){return 1 - Math.pow(1 - t, 3)}
    const now = () => performance.now();

    // rng
    function mulberry32(a){return function(){let t=a+=0x6D2B79F5; t=Math.imul(t ^ (t>>>15), t | 1); t ^= t + Math.imul(t ^ (t>>>7), t | 61); return ((t ^ (t>>>14))>>>0)/4294967296 }}

    function getDifficulty(n){const cycle = n % 6; if(cycle<2) return 0; if(cycle<4) return 5; return 9}

    function genLevel(width,height,difficulty){
      const tiles = Array.from({length:height},()=>Array(width).fill(0));
      const rng = mulberry32(1000 + difficulty*1337 + Math.floor(Math.random()*1e6));
      const groundY = height-3;
      const gapChance = clamp(0.05 + difficulty*0.02, 0.05, 0.26);
      for(let x=0;x<width;x++){ if(rng()<gapChance && x>10 && x<width-12){} else { tiles[groundY][x]=1; if(tiles[groundY+1]) tiles[groundY+1][x]=1 }}
      const platformCount = Math.floor(60 - difficulty*3);
      for(let i=0;i<platformCount;i++){ const len = Math.floor(2 + rng()*(6 - difficulty*0.3)); const px = Math.floor(rng()*(width-len-6))+3; const py = Math.floor(rng()*(height-10))+5+Math.floor(difficulty*0.5); for(let k=0;k<len;k++) tiles[py][clamp(px+k,1,width-2)]=1; if(rng() < (0.15 + difficulty*0.04)) { const hx = clamp(px + Math.floor(len/2),1,width-2); tiles[py-1][hx]=2 } }
      const pillarCount = Math.floor(8 + difficulty*2);
      for(let i=0;i<pillarCount;i++){ const px = Math.floor(rng()*(width-6))+3; const baseY = Math.floor(rng()*6) + (groundY-6); for(let j=0;j<4;j++) tiles[baseY-j][px]=1; if(rng()<0.32) tiles[baseY-4][px]=2 }
      const gx = width - 8; const gy = groundY - 2; for(let k=0;k<6;k++) tiles[gy][gx+k]=1; tiles[gy-1][gx+2]=3;
      const boxW = 4, boxH=3; for(let by=0;by<boxH;by++){ for(let bx=0;bx<boxW;bx++){ const wx=gx+bx, wy=gy-1+by; const edge = by===0||by===boxH-1||bx===0||bx===boxW-1; if(edge && tiles[wy][wx]!==3) tiles[wy][wx]=4 }}
      level.goalBox = { x: gx*TILE, y: (gy-1)*TILE, w: boxW*TILE, h: boxH*TILE };
      level.spawn = { x: TILE*2, y: TILE*(groundY-4) };
      return tiles;
    }

    // tile helpers
    function tileAt(x,y){ const tx=Math.floor(x/TILE), ty=Math.floor(y/TILE); if(tx<0||ty<0||tx>=level.width||ty>=level.height) return 0; return level.tiles[ty]?.[tx] ?? 0 }
    function rectVsLevel(x,y,w,h){ const left=Math.floor(x/TILE), right=Math.floor((x+w)/TILE); const top=Math.floor(y/TILE), bottom=Math.floor((y+h)/TILE); const hits=[]; for(let ty=top;ty<=bottom;ty++){ for(let tx=left;tx<=right;tx++){ if(tx<0||ty<0||tx>=level.width||ty>=level.height) continue; const t = level.tiles[ty]?.[tx] ?? 0; if(t===1||t===4) hits.push({tx,ty,kind:'solid'}); else if(t===2) hits.push({tx,ty,kind:'hazard'}); else if(t===3) hits.push({tx,ty,kind:'goal'}); }} return hits }

    // player
     const player = {x:TILE*2,y:TILE*2,w:22,h:30,vx:0,vy:0,onGround:false,onWall:0,facing:1,moveAccel:2200,maxRun:360,airAccel:1400,friction:2400,gravity:2400,jumpVel:-720,doubleJump:true,coyoteTime:0,jumpBuffer:0,dashReady:true,dashTimer:0,dashCd:600,dashSpeed:780,trail:[],color:config.accent1,squash:0 };

    // particles
    const particles = [];
    function configAccent(){ return Math.random() < 0.5 ? config.accent1 : config.accent2 }
    function spawnParticle(x,y,opts={}){
      if(particles.length > config.particleLimit) return;
      particles.push({ x, y, vx: opts.vx ?? (Math.random()*140-70), vy: opts.vy ?? (Math.random()*140-70), life: opts.life ?? 360, t:0, size: opts.size ?? (1 + Math.random()*2), color: opts.color ?? configAccent(), fade: opts.fade ?? 1 });
    }
    function clearParticles(){ particles.length = 0 }

    // stars
    const stars = Array.from({ length: config.starCount }, ()=>({ x: Math.random() * (level.width * TILE), y: Math.random() * (level.height * TILE), r: Math.random()*1.8 + 0.5, c: Math.random() < 0.6 ? config.accent1 : config.accent2, tw: Math.random()*9000 + 1000 }))

    function spawnJumpFX(color = player.color){ for(let i=0;i<20;i++){ const ang=(i/20)*Math.PI*2; spawnParticle(player.x + player.w/2, player.y + player.h, { vx: Math.cos(ang)*(120+Math.random()*60), vy: Math.sin(ang)*(120+Math.random()*60), life: 340, color, size: 2 + Math.random()*2 }) } player.squash = 0.24 }
    function spawnDashTrail(){ player.trail.push({ x: player.x + player.w/2, y: player.y + player.h/2, t: 0 }); if(player.trail.length > 50) player.trail.shift(); for(let i=0;i<6;i++) spawnParticle(player.x + player.w/2, player.y + player.h/2, { life: 220, size: 1.6, color: config.accent2 }) }
    function landDust(){ for(let i=0;i<12;i++) spawnParticle(player.x + player.w/2, player.y + player.h, { vx:(Math.random()*180-90), vy: Math.random()*-220, life: 300, size:2, color: config.accent3 }); player.squash = -0.2 }
    function speedLines(){ if(Math.abs(player.vx) > 420){ for(let i=0;i<2;i++){ spawnParticle(player.x + player.w/2 + (player.facing*8), player.y + player.h/2, { vx: -player.facing*(160 + Math.random()*60), vy: Math.random()*40 - 20, life: 140, size: 2, color: config.accent1 }) } } }

    // reset / progression
    function resetPlayer(spawn = level.spawn, loseLife = true){ if(loseLife){ lives--; if(lives <= 0){ gameOverScreen(); return } else { toast(`You fell! Lives: ${lives}`) } } player.x = spawn.x; player.y = spawn.y; player.vx = 0; player.vy = 0; player.onGround = false; player.onWall = 0; player.doubleJump = true; player.dashReady = true; player.dashTimer = 0; player.trail.length = 0; updateHUD(); }

    function stageWon(){ if(!gameStarted || !running || !levelCleared) return; lives = Math.min(lives + 1, 9); score += 150 + Math.floor((stageCounter + 1) * 30); stageMsg.textContent = `Stage ${stageCounter + 1} cleared — Lives: ${lives} • Score: ${score}`; nextBtn.textContent = 'Next'; show(winScreen); saveHighScore(score); running = false }
    function goToNextStage(){ levelCleared = false; stageCounter++; level.tiles = genLevel(level.width, level.height, getDifficulty(stageCounter)); resetPlayer(level.spawn, false); hide(winScreen); running = true; last = now(); loop() }
    nextBtn.addEventListener('click', ()=>{ if(!gameStarted) return; goToNextStage(); })
    homeBtn.addEventListener('click', ()=>{ hide(winScreen); show(menu); hud.style.display='none'; canvas.classList.add('hidden'); running=false; gameStarted=false })

    function gameOverScreen(){ running=false; finalScore.textContent = `Your Score: ${score}`; show(gameOver); saveHighScore(score) }
    restartBtn.addEventListener('click', ()=>{ hide(gameOver); startGame() })
    backBtn.addEventListener('click', ()=>{ hide(gameOver); show(menu); hud.style.display='none'; canvas.classList.add('hidden'); running=false; gameStarted=false })

    // teleport hazards
    function teleportToSafe(){ let safeX, safeY, tries=0; do{ safeX = Math.floor(Math.random() * level.width) * TILE; safeY = Math.floor(Math.random() * (level.height - 6)) * TILE; tries++; if(tries > 500){ safeX = level.spawn.x; safeY = level.spawn.y; break } } while(tileAt(safeX, safeY) !== 0); player.x = safeX; player.y = safeY; player.vx = 0; player.vy = 0 }

    // input
    function handleInput(dt){ const left = keys.has('ArrowLeft') || keys.has('KeyA'); const right = keys.has('ArrowRight') || keys.has('KeyD'); const jumpPressed = keyOnce.has('Space'); const jumpHeld = keys.has('Space'); const dashPressed = keyOnce.has('ShiftLeft') || keyOnce.has('ShiftRight'); keyOnce.clear(); if(jumpPressed) player.jumpBuffer = 130; else player.jumpBuffer = Math.max(0, player.jumpBuffer - dt); const dir = (left ? -1 : 0) + (right ? 1 : 0); if(dir !== 0) player.facing = dir; const accel = player.onGround ? player.moveAccel : player.airAccel; player.vx += dir * accel * (dt/1000); if(dir === 0 && player.onGround && player.dashTimer <= 0){ const sign = Math.sign(player.vx); const mag = Math.max(0, Math.abs(player.vx) - player.friction * (dt/1000)); player.vx = mag * sign } if(player.dashTimer <= 0) player.vx = clamp(player.vx, -player.maxRun, player.maxRun); if(player.dashTimer <= 0){ const g = jumpHeld && player.vy < 0 ? player.gravity * 0.6 : player.gravity; player.vy += g * (dt/1000) } const canJump = player.onGround || player.coyoteTime > 0 || player.onWall !== 0; if(player.jumpBuffer > 0 && canJump){ if(player.onWall !== 0 && !player.onGround){ player.vy = player.jumpVel * 0.92; player.vx = -player.onWall * (player.maxRun * 0.9); spawnJumpFX(); playSfx('jump') } else { player.vy = player.jumpVel; spawnJumpFX(); playSfx('jump') } player.onGround = false; player.coyoteTime = 0; player.jumpBuffer = 0; player.doubleJump = true } else if(player.jumpBuffer > 0 && !player.onGround && player.doubleJump){ player.vy = player.jumpVel * 0.9; player.doubleJump = false; spawnJumpFX(config.accent2); player.jumpBuffer = 0; playSfx('jump2') }

      // Dash
      if(dashPressed && player.dashReady && player.dashTimer <= 0){ const dirX = dir !== 0 ? dir : player.facing; player.dashTimer = 140; player.dashReady = false; player.vx = dirX * player.dashSpeed; player.vy = 0; spawnDashTrail(); playSfx('dash'); setTimeout(()=>player.dashReady = true, player.dashCd) }
      if(player.dashTimer > 0){ player.dashTimer -= dt; spawnDashTrail() }
      speedLines();
    }

    // physics
    function physics(dt){ const px = player; const prevX = px.x; px.x += px.vx * (dt/1000); let hits = rectVsLevel(px.x, px.y, px.w, px.h); let collidedX = false; for(const h of hits){ if(h.kind === 'solid'){ const tx=h.tx*TILE, ty=h.ty*TILE; const prevPosX = prevX; const tileRect = {x:tx,y:ty,w:TILE,h:TILE}; if(prevPosX + px.w <= tileRect.x){ px.x = tileRect.x - px.w - 0.01; collidedX=true; px.vx = Math.min(px.vx,0); px.onWall = 1 } else if(prevPosX >= tileRect.x + tileRect.w){ px.x = tileRect.x + tileRect.w + 0.01; collidedX=true; px.vx = Math.max(px.vx,0); px.onWall = -1 } } else if(h.kind === 'hazard'){ teleportToSafe(); toast('Purple warp!'); playSfx('warp'); return } else if(h.kind === 'goal'){ if(running && gameStarted){ levelCleared=true; stageWon() } return } }
      if(!collidedX) px.onWall = 0;

      // vertical
      const prevY = px.y; const prevOnGround = px.onGround; px.y += px.vy * (dt/1000); hits = rectVsLevel(px.x, px.y, px.w, px.h); px.onGround = false; for(const h of hits){ if(h.kind === 'solid'){ const tx=h.tx*TILE, ty=h.ty*TILE; const tileRect = {x:tx,y:ty,w:TILE,h:TILE}; const prevPosY = prevY; if(prevPosY + px.h <= tileRect.y){ px.y = tileRect.y - px.h - 0.01; px.vy = Math.min(px.vy,0); if(!px.onGround){ px.onGround = true; px.doubleJump = true; landDust(); playSfx('land') } } else if(prevPosY >= tileRect.y + tileRect.h){ px.y = tileRect.y + tileRect.h + 0.01; px.vy = Math.max(px.vy,0) } } else if(h.kind === 'hazard'){ teleportToSafe(); toast('Purple warp!'); playSfx('warp'); return } else if(h.kind === 'goal'){ if(running && gameStarted){ levelCleared=true; stageWon() } return } }

      if(prevOnGround && !px.onGround) px.coyoteTime = 120; else px.coyoteTime = Math.max(0, px.coyoteTime - dt);
      if(px.onWall !== 0 && !px.onGround && px.vy > 0 && px.dashTimer <= 0) px.vy = Math.min(px.vy, 250);
      if(px.y > level.height * TILE + TILE*4) resetPlayer(level.spawn, true);
      player.squash = lerp(player.squash, 0, 0.12);
    }

    // camera
    const camera = { x:0,y:0,shake:0,shakeT:0,apply(){ ctx.setTransform(1,0,0,1,0,0); ctx.translate(Math.floor(-this.x), Math.floor(-this.y)) }}
    function applyCamera(dt){ const targetX = player.x + player.w/2 - canvas.width/2 / (config.dpr); const targetY = player.y + player.h/2 - canvas.height/2 / (config.dpr); camera.x = lerp(camera.x, targetX, easeOut(0.12)); camera.y = lerp(camera.y, targetY, easeOut(0.12)); camera.x = clamp(camera.x, 0, level.width*TILE - canvas.width); camera.y = clamp(camera.y, 0, level.height*TILE - canvas.height); if(camera.shakeT > 0){ camera.shakeT -= dt; const s = camera.shake * (camera.shakeT / 200); camera.x += (Math.random()*2 - 1) * s; camera.y += (Math.random()*2 - 1) * s } }

    // rendering
    function drawBackground(){ // deep cosmic gradient + aurora bands + stars
      ctx.fillStyle = '#030516'; ctx.fillRect(camera.x, camera.y, canvas.width, canvas.height);
      const g = ctx.createLinearGradient(0, camera.y, 0, camera.y + canvas.height);
      g.addColorStop(0, 'rgba(20,8,40,0.75)'); g.addColorStop(0.5, 'rgba(6,8,30,0.6)'); g.addColorStop(1, 'rgba(2,2,12,0.95)');
      ctx.fillStyle = g; ctx.fillRect(camera.x, camera.y, canvas.width, canvas.height);

      // aurora layers
      ctx.save(); ctx.globalCompositeOperation = 'lighter'; ctx.globalAlpha = 0.22; const time = performance.now()/1000; for(let i=0;i<3;i++){ const amp = 120 + i*40; const speed = 0.06 + i*0.02; const y = (Math.sin(time * speed + i) * 40) + (canvas.height*0.15) + i*60; const grad = ctx.createLinearGradient(0, y-120, 0, y+120); grad.addColorStop(0, 'rgba(255,93,240,0.04)'); grad.addColorStop(0.5, 'rgba(73,240,255,0.06)'); grad.addColorStop(1, 'rgba(112,255,97,0.02)'); ctx.fillStyle = grad; ctx.beginPath(); ctx.ellipse(camera.x + (Math.sin(time*0.12+i)*120), camera.y + y, canvas.width*0.7, amp, 0, 0, Math.PI*2); ctx.fill(); } ctx.restore();

      // stars
      for(const s of stars){ const sx = s.x - camera.x * 0.12; const sy = s.y - camera.y * 0.12; const tw = (Math.sin((performance.now()%s.tw)/s.tw * Math.PI*2) * 0.5 + 0.5); ctx.globalAlpha = 0.9 * tw; ctx.beginPath(); ctx.arc(sx, sy, s.r, 0, Math.PI*2); ctx.fillStyle = s.c; ctx.fill(); } ctx.globalAlpha = 1;
    }

    function drawLevel(){ for(let y=0;y<level.height;y++){ for(let x=0;x<level.width;x++){ const t = level.tiles[y]?.[x] ?? 0; if(t===0) continue; const px = x*TILE, py = y*TILE; if(t===1){ ctx.fillStyle='rgba(255,255,255,0.02)'; ctx.fillRect(px,py,TILE,TILE); ctx.strokeStyle='rgba(73,240,255,0.35)'; ctx.lineWidth = 1.6; ctx.strokeRect(px+1,py+1,TILE-2,TILE-2); const gg = ctx.createLinearGradient(px,py,px,py+TILE); gg.addColorStop(0,'rgba(112,255,97,0.04)'); gg.addColorStop(1,'rgba(73,240,255,0.02)'); ctx.fillStyle=gg; ctx.fillRect(px+2,py+2,TILE-4,TILE-4); } else if(t===2){ ctx.fillStyle='rgba(255,93,240,0.05)'; ctx.fillRect(px,py,TILE,TILE); ctx.strokeStyle= 'rgba(255,93,240,0.9)'; ctx.lineWidth=1.8; ctx.strokeRect(px+1,py+1,TILE-2,TILE-2); ctx.fillStyle='#ff5df0'; ctx.beginPath(); ctx.moveTo(px+TILE*0.2,py+TILE*0.8); ctx.lineTo(px+TILE*0.5,py+TILE*0.4); ctx.lineTo(px+TILE*0.8,py+TILE*0.8); ctx.fill(); } else if(t===3){ ctx.strokeStyle= 'rgba(112,255,97,0.95)'; ctx.lineWidth=2; ctx.strokeRect(px+4,py+4,TILE-8,TILE-8); ctx.beginPath(); ctx.arc(px+TILE/2,py+TILE/2,8,0,Math.PI*2); ctx.fillStyle='#70ff61'; ctx.fill(); ctx.globalAlpha = 0.16; ctx.beginPath(); ctx.arc(px+TILE/2,py+TILE/2,20,0,Math.PI*2); ctx.fill(); ctx.globalAlpha = 1.0; } else if(t===4){ ctx.strokeStyle='rgba(112,255,97,0.45)'; ctx.lineWidth=1.6; ctx.strokeRect(px+1,py+1,TILE-2,TILE-2) } } } }

function drawPlayer() {
  if (!isFinite(player.x) || !isFinite(player.y)) return;

  const w = player.w || 22;
  const h = player.h || 30;
  const cx = player.x + w / 2;
  const cy = player.y + h / 2;
  const color = player.color || config.accent1 || '#00fff0';
  const scale = player.dashing ? 1.4 : 1.0;

  ctx.save();

  // --- Outer glow / aura ---
  const r = Math.max(Math.max(w, h) * 0.6 * scale, 4);
  const grad = ctx.createRadialGradient(cx, cy, 0, cx, cy, r * 2);
  grad.addColorStop(0, 'rgba(255,255,255,0.8)');
  grad.addColorStop(0.3, color);
  grad.addColorStop(1, 'rgba(0,0,0,0)');

  ctx.beginPath();
  ctx.arc(cx, cy, r * 1.8, 0, Math.PI * 2);
  ctx.fillStyle = grad;
  ctx.fill();

  // --- Solid comet core ---
  ctx.beginPath();
  ctx.arc(cx, cy, r * 0.6, 0, Math.PI * 2);
  ctx.fillStyle = color;
  ctx.globalAlpha = 0.95;
  ctx.shadowColor = color;
  ctx.shadowBlur = player.dashing ? 25 : 10;
  ctx.fill();

  ctx.restore();
}




    function drawParticles(dt){ for(let i=particles.length-1;i>=0;i--){ const p = particles[i]; p.t += dt; p.x += p.vx * (dt/1000); p.y += p.vy * (dt/1000); const a = clamp(1 - p.t / p.life, 0, 1) * p.fade; ctx.globalAlpha = a; ctx.fillStyle = p.color; ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI*2); ctx.fill(); ctx.globalAlpha = 1; if(p.t >= p.life) particles.splice(i,1) } }

    function updateHUD(){ statsLives.textContent = `Lives: ${lives}`; statsStage.textContent = `Stage: ${stageCounter + 1}`; statsScore.textContent = `Score: ${score}`; [statsLives, statsStage, statsScore].forEach(el => { el.classList.remove('pulse'); void el.offsetWidth; el.classList.add('pulse'); }) }

    // main loop
    let last = now();
    function loop(){ if(!running) return; const t = now(); let dt = t - last; dt = clamp(dt, 0, 40); last = t; handleInput(dt); physics(dt); applyCamera(dt);
      ctx.setTransform(1,0,0,1,0,0); ctx.fillStyle = '#020518'; ctx.fillRect(0,0,canvas.width,canvas.height);
      camera.apply(); drawBackground(); drawLevel(); drawPlayer(); drawParticles(dt);
      updateHUD(); requestAnimationFrame(loop);
    }

    // start
    function startGame(){ hide(menu); showHUD(); canvas.classList.remove('hidden'); gameStarted=true; running=true; stageCounter=0; lives=5; score=0; level.tiles = genLevel(level.width, level.height, getDifficulty(stageCounter)); resetPlayer(level.spawn, false); last = now(); toast('Reach the green goal at the far right.'); loop(); }
    startBtn.addEventListener('click', startGame);

    function showHUD(){ hud.style.display='flex'; controls.style.display='flex'; touchControls.style.display='flex'; }
    function show(el){ el.style.display = 'flex' }
    function hide(el){ el.style.display = 'none' }

    // scoreboard
    function loadHighScores(){ try{ return JSON.parse(localStorage.getItem('neon_highscores') || '[]') }catch(e){return []} }
    function saveHighScore(val){ if(typeof val !== 'number') return; const list = loadHighScores(); list.push({score:val, date: new Date().toISOString()}); list.sort((a,b)=>b.score - a.score); const top = list.slice(0,12); localStorage.setItem('neon_highscores', JSON.stringify(top)); }
    function showScores(){ const list = loadHighScores(); scoreList.innerHTML = list.length ? list.map((s,i)=>`<li>${i+1}. ${s.score} <small style="color:rgba(255,255,255,0.55)">(${new Date(s.date).toLocaleString()})</small></li>`).join('') : '<li>(no scores yet)</li>'; show(scoreBoard); hide(menu); }
    scoreBtn.addEventListener('click', showScores); closeScore.addEventListener('click', ()=>{ hide(scoreBoard); show(menu) }); clearScore.addEventListener('click', ()=>{ if(confirm('Clear local high scores?')){ localStorage.removeItem('neon_highscores'); showScores() } })

    // settings
    settingsBtn.addEventListener('click', ()=>{ show(settings); hide(menu); perfSelect.value = 'balanced'; sfxToggle.checked = config.sfx });
    closeSettings.addEventListener('click', ()=>{ hide(settings); show(menu); config.sfx = sfxToggle.checked; applyPerfPreset(perfSelect.value) });
    function applyPerfPreset(v){ if(v==='mobile'){ config.particleLimit = 140; config.starCount = 120 } else if(v==='high'){ config.particleLimit = 650; config.starCount = 420 } else { config.particleLimit = 350; config.starCount = 260 } }

    // touch binding
    touchControls.querySelectorAll('.touch-btn').forEach(btn => { const code = btn.dataset.key; const press = () => { keys.add(code); keyOnce.add(code) }; const release = () => { keys.delete(code) }; btn.addEventListener('touchstart', e => { e.preventDefault(); press(); }); btn.addEventListener('touchend', e => { e.preventDefault(); release(); }); btn.addEventListener('mousedown', e => { e.preventDefault(); press(); }); btn.addEventListener('mouseup', e => { e.preventDefault(); release(); }); btn.addEventListener('mouseleave', release); });

    // ensure overlays hidden
    [winScreen, gameOver, scoreBoard, settings].forEach(el => el.style.display = 'none');

    // audio (ambient pad + SFX)
    const AudioCtx = window.AudioContext || window.webkitAudioContext;
    const audio = AudioCtx ? new AudioCtx() : null;
    let ambientNode = null;
    function startAmbient(){ if(!audio || !config.sfx) return; // simple ambient pad using oscillators + filter
      const t = audio.currentTime;
      const g = audio.createGain(); g.gain.value = 0.06; g.connect(audio.destination);
      const o1 = audio.createOscillator(); o1.type = 'sine'; o1.frequency.value = 110; const o2 = audio.createOscillator(); o2.type = 'sine'; o2.frequency.value = 165; const f = audio.createBiquadFilter(); f.type = 'lowpass'; f.frequency.value = 800; o1.connect(f); o2.connect(f); f.connect(g); o1.start(t); o2.start(t); ambientNode = { o1, o2, f, g }; }
    function stopAmbient(){ if(!ambientNode) return; ambientNode.o1.stop(); ambientNode.o2.stop(); ambientNode.g.disconnect(); ambientNode = null }
    function playSfx(kind){ if(!config.sfx || !audio) return; const t = audio.currentTime; const g = audio.createGain(); g.gain.value = 0.12; g.connect(audio.destination);
      if(kind === 'jump'){ const o = audio.createOscillator(); o.type='sine'; o.frequency.setValueAtTime(420, t); o.frequency.exponentialRampToValueAtTime(720, t+0.12); o.connect(g); o.start(t); o.stop(t+0.12) }
      else if(kind === 'jump2'){ const o = audio.createOscillator(); o.type='triangle'; o.frequency.setValueAtTime(360,t); o.frequency.exponentialRampToValueAtTime(640,t+0.18); o.connect(g); o.start(t); o.stop(t+0.18) }
      else if(kind === 'dash'){ const o=audio.createOscillator(); o.type='sawtooth'; o.frequency.setValueAtTime(240,t); o.frequency.exponentialRampToValueAtTime(520,t+0.08); o.connect(g); o.start(t); o.stop(t+0.12) }
      else if(kind==='warp'){ const o = audio.createOscillator(); o.type='sine'; o.frequency.setValueAtTime(220,t); const bi = audio.createOscillator(); bi.type='sine'; bi.frequency.setValueAtTime(120,t); bi.connect(g); o.connect(g); o.start(t); bi.start(t); o.stop(t+0.16); bi.stop(t+0.16) }
      else if(kind==='land'){ const o=audio.createOscillator(); o.type='sine'; o.frequency.setValueAtTime(180,t); o.connect(g); o.start(t); o.stop(t+0.08) }
    }
    window.addEventListener('pointerdown', ()=>{ if(audio && audio.state === 'suspended') audio.resume().then(()=>{ if(config.sfx) startAmbient() }) }, { once:true });

    // small toast
    let toastTimer = 0;
    function toast(msg, t=1500){ toastEl.textContent = msg; toastEl.style.display='block'; clearTimeout(toastTimer); toastTimer=setTimeout(()=>toastEl.style.display='none',t); }

    // start with generated level
    level.tiles = genLevel(level.width, level.height, getDifficulty(stageCounter));

    // expose for debugging
    window.NEON = { player, level, genLevel };
  });
  </script>
</body>
</html>